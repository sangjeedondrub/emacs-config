#+TITLE: Navigation configuration

Let's configure general navigation elements of emacs here. By that I
mean using modal edition (like =evil=) but also command and search
like =ivy= and =counsel=.

* Evil

#+BEGIN_QUOTE
Evil Mode, or, How I Learned to Stop Worrying and Love Emacs
#+END_QUOTE

As [[https://blog.aaronbieber.com/][Aaron Bieber]] says in one of his [[https://blog.aaronbieber.com/2015/06/03/evil-mode.html][talk]], let's stop worrying and use
best of both worlds.

First let's define the =vde:config-evil= function ðŸ‘¼.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun vde:config-evil ()
    "Configure evil mode the way I want"
    (vde:evil:configure-emacs-mode)
    (vde:evil:configure-bepo))
#+END_SRC

Some modes will work better with =emacs= evil mode, i.e. not the
default vim =normal= mode or =insert= mode. One example would be
=grep-mode= which has already pretty useful one key bindings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun vde:evil:configure-emacs-mode ()
    "configure evil emacs mode"
    (dolist (mode '(custom-mode
                    dired-mode
                    eshell-mode
                    term-mode
                    grep-mode))
      (add-to-list 'evil-emacs-state-modes mode)))
#+END_SRC

I am a =bÃ©po= user in /most/ of my computer. This means the default
vim bindings of evil are really not optimized for my keyboard
layout. That said in a few (macbook at work/home and on tablets) I am
using mainly qwerty or azerty. Soâ€¦

I need to rebind those bindings to bÃ©po-optimized bindings,
/conditionaly/. Any bindings I do for evil (and in general) should act
the same with my bÃ©po keymap *and* a qwerty/azerty keymap. This means
I need a way to rebind dynamically some stuff â€” well not that
dynamically but I need to have *one way* to bind things (the qwerty
way) that should be translated to the =bÃ©po=-way if I'm on a bÃ©po
computer. We'll detect they keyboard layout using a variable that
needs to be set-up on bÃ©po machines.

Let's first create a map that correspond one bÃ©po char to a qwerty
char.

#+BEGIN_SRC emacs-lisp :tangle no
    (defvar vde:bepo-base-rebinding-map
      (;;row0
       ("=" . "-")
       ;;row1
       ("b" . "q")
       ("Ã©" . "w")
       ("p" . "e")
       ("o" . "r")
       ("Ã¨" . "t")
       ("^" . "y")
       ("v" . "u")
       ("d" . "i")
       ("l" . "o")
       ("j" . "p")
       ("z" . "[")
       ;;row2
       ("a" . "a")
       ("u" . "s")
       ("i" . "d")
       ("e" . "f")
       ("," . "g")
       ("c" . "h")
       ("t" . "j")
       ("s" . "k")
       ("r" . "l")
       ("n" . ";")
       ("m" . "'")
       ;;row3
       ("Ã " . "z")
       ("y" . "x")
       ("x" . "c")
       ("." . "v")
       ("k" . "b")
       ("'" . "n")
       ("q" . "m")
       ("g" . ",")
       ("h" . ".")
       ("f" . "/")
       ("w" . "]")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun vde:evil:configure-bepo ()
    "Remap default bindings to bÃ©po one *if* the computer is
    running on a bÃ©po keyboard layout.")
#+END_SRC

Finally let's tie this altogether.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil
    :ensure t
    :config
    (add-hook 'evil-mode-hook 'vde:config-evil)
    (evil-mode 1)
    (use-package evil-jumper
      :ensure t
      :config
      (global-evil-jumper-mode))
    (use-package evil-surround
      :ensure t
      :config
      (global-evil-surround-mode))
    (use-package evil-indent-textobject
      :ensure t))
#+END_SRC

* Which key

 Emacs has 100s of bindings and it is impossible to remember them all. Sometimes
 I can remember the start of a key chord but not the entire one. [[https://github.com/justbur/emacs-which-key][which-key]] is a
 package that gives you key hints on delay or if prompted. I really like it and
 use it extensively to setup the modal state.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :init
    (setq which-key-sort-order 'which-key-key-order-alpha)
    :config
    (which-key-mode))
#+END_SRC

* Ivy, counsel and swiper

[[https://github.com/abo-abo/swiper][ivy, counsel and swiper]] are a bunch of packages from the awesome [[https://github.com/abo-abo][abo-abo]] that
provides a very good and lightweight alternative to =helm=.

- Ivy is a genery completion mechanism for Emacs.
- Counsel is a collection of ivy-enhanced versions of common Emacs commands.
- Swiper is an ivy-enhanced alternative to isearch.

** ivy

> Ivy is a generic completion mechanism for Emacs. While it operates similarly
> to other completion schemes such as icomplete-mode, Ivy aims to be more
> efficient, smaller, simpler, and smoother to use yet highly customizable.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ivy
    :ensure t
    :diminish ivy-mode
    :config
    (use-package ivy-hydra
      :ensure t)
    (ido-mode -1)
    (ivy-mode 1)  ;; Show recently killed buffers when calling `ivy-switch-buffer'
    (setq ivy-use-virtual-buffers t)
    (defun modi/ivy-kill-buffer ()
      (interactive)
      (ivy-set-action 'kill-buffer)
      (ivy-done))
    (bind-keys
     :map ivy-switch-buffer-map
     ("C-k" . modi/ivy-kill-buffer))
    (bind-keys
     :map ivy-minibuffer-map
     ;; Exchange the default bindings for C-j and C-m
     ("C-m" . ivy-alt-done) ; RET, default C-j
     ("C-j" . ivy-done) ; default C-m
     ("C-S-m" . ivy-immediate-done)
     ("C-t" . ivy-toggle-fuzzy)
     ("C-o" . hydra-ivy/body))
    ;; version of ivy-yank-word to yank from start of word
    (defun bjm/ivy-yank-whole-word ()
      "Pull next word from buffer into search string."
      (interactive)
      (let (amend)
    (with-ivy-window
          ;;move to last word boundary
          (re-search-backward "\\b")
          (let ((pt (point))
            (le (line-end-position)))
            (forward-word 1)
            (if (> (point) le)
            (goto-char pt)
              (setq amend (buffer-substring-no-properties pt (point))))))
    (when amend
          (insert (replace-regexp-in-string " +" " " amend)))))

    ;; bind it to M-j
    (define-key ivy-minibuffer-map (kbd "M-j") 'bjm/ivy-yank-whole-word))
#+END_SRC

** counsel

> ivy-mode ensures that any Emacs command using completing-read-function uses
> ivy for completion. Counsel takes this further, providing versions of common
> Emacs commands that are customised to make the best use of ivy. For example,
> counsel-find-file has some additional keybindings. Pressing DEL will move you
> to the parent directory.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :ensure t
    :bind*                    
    (("M-x"     . counsel-M-x)
     ("M-y"     . counsel-yank-pop)
     ("C-x C-f" . counsel-find-file)
     ("C-x C-r" . counsel-recentf)
     ("C-c f"   . counsel-git)
     ("C-c s"   . counsel-git-grep)
     ("C-c /"   . counsel-ag))
    :config
    (progn
      (ivy-set-actions
       'counsel-find-file
       '(("d" (lambda (x) (delete-file (expand-file-name x)))
          "delete"
          )))
      (ivy-set-actions
       'ivy-switch-buffer
       '(("k" (lamba (x)
                     (kill-buffer x)
                     (ivy--reset-state ivy-last))
          "kill")
     ("j"
          ivy--switch-buffer-other-window-action
          "other window")))
      )
    )
#+END_SRC

* Project management

In order to manage project under Emacs, the most used package is =projectile=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :ensure t
    :init
    (setq projectile-enable-caching t
          projectile-verbose nil
          projectile-completion-system 'ivy)
    (put 'projectile-project-run-cmd 'safe-local-variable #'stringp)
    (defun projectile-do-invalidate-cache (&rest _args)
      (projectile-invalidate-cache nil))
    (advice-add 'rename-file :after #'projectile-do-invalidate-cache)
    (projectile-mode)
    (projectile-cleanup-known-projects))

  (use-package counsel-projectile
    :ensure t
    :after projectile
    :config (counsel-projectile-on))

  (use-package persp-projectile
    :ensure t
    :after projectile)
#+END_SRC

* General

A good complement to =evil= is the [[https://github.com/noctuid/general.el][general]].

> general.el provides a more convenient way to bind keys in emacs for both evil
> and non-evil users. general-define-key allows defining multiple keys at once,
> implicitly wrapping key strings with (kbd ...), having named prefix key
> sequences (like the leader key in vim), and more.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package general
    :ensure t
    :after projectile
    :config
    (let ((leader "SPC")
          (emacs-leader "M-m"))
      (general-define-key
       :states '(normal visual insert emacs)
       :prefix leader
       :non-normal-prefix emacs-leader
       "p" 'projectile-command-map
       "TAB" '(ivy-switch-buffer :which-key "switch buffer")
       "/" '(:ignore t :which-key "search")
       "/a" '(counsel-ag :which-key "ag")
       "/g" '(counsel-git-grep :which-key "git grep")
       "y" '(counsel-yank-pop :which-key "yank-pop")
       "SPC" '(counsel-M-x :which-key "M-x")
       "f" '(:ignore t :which-key "Files")
       "ff" '(counsel-find-file :which-key "find file")
       "fd" '(counsel-git :which-key "find file in git")
       "r" '(counsel-recentf :which-key "recent file"))))
#+END_SRC


* Provide configuration

#+BEGIN_SRC emacs-lisp :tangle yes
  (provide 'navigation-config)
#+END_SRC

